Apache AGE (A Graph Extension) is an extension that allows PostgreSQL to function as a graph database. To optimize performance, especially for large datasets, you can utilize PostgreSQL's native features for indexing and partitioning. Unlike some native graph databases, Apache AGE does not automatically create indexes, so you must create them manually using standard SQL syntax.
Indexing in Apache AGE
Indexing in Apache AGE is crucial for improving query performance, particularly for MATCH clauses with WHERE conditions. You create indexes on the underlying PostgreSQL tables that Apache AGE uses to store your graph data.
Understanding the Underlying Tables
When you create a graph and add vertices and edges, Apache AGE automatically generates relational tables to store this data.
ag_catalog."VLABEL": This table stores all vertices. Each vertex has an id and a properties column.
ag_catalog."ELABEL": This table stores all edges. Each edge has an id, start_id, end_id, and properties column.
The VLABEL and ELABEL are placeholders for the actual table names, which are created with the format graph_name."LABEL_NAME". For example, a Person vertex in a my_graph graph would be stored in a table named my_graph."Person".
Common Index Types
B-Tree Indexes: These are effective for exact matches and range queries on single columns. They are highly recommended for the id, start_id, and end_id columns.
GIN (Generalized Inverted Index) Indexes: These are ideal for the properties column, which is a JSONB type. A GIN index allows you to efficiently search for specific key-value pairs within the JSON data without scanning the entire table.
Creating Indexes
You use standard CREATE INDEX SQL statements to create these indexes.
1. Indexing on Vertex and Edge IDs
These indexes are essential for fast lookups by ID.
-- Create a B-Tree index on the 'id' column of a vertex table
CREATE INDEX ON my_graph."Person" USING BTREE (id);

-- Create a B-Tree index on the 'id' column of an edge table
CREATE INDEX ON my_graph."WORKS_AT" USING BTREE (id);

-- Create B-Tree indexes on the 'start_id' and 'end_id' columns of an edge table
CREATE INDEX ON my_graph."WORKS_AT" USING BTREE (start_id);
CREATE INDEX ON my_graph."WORKS_AT" USING BTREE (end_id);


2. Indexing on the properties Column (for JSONB data)
A GIN index allows for efficient queries on properties.
-- Create a GIN index on the entire 'properties' column of a vertex table
CREATE INDEX ON my_graph."Person" USING GIN (properties);

-- Create a GIN index on the entire 'properties' column of an edge table
CREATE INDEX ON my_graph."WORKS_AT" USING GIN (properties);


3. Indexing a Specific Key within the properties Column
For queries that often filter by a single, specific property (e.g., n.name = 'Alice'), you can create a more targeted and efficient B-Tree index using the agtype_access_operator function. This approach is more performant than a full GIN index if you only need to query on a few specific keys.
-- Index on a specific key 'name' within the properties of the 'Person' vertex
CREATE INDEX ON my_graph."Person" USING BTREE (agtype_access_operator(VARIADIC ARRAY[properties, '"name"'::agtype]));

-- Index on a specific key 'title' within the properties of the 'Movie' vertex
CREATE INDEX ON my_graph."Movie" USING BTREE (agtype_access_operator(VARIADIC ARRAY[properties, '"title"'::agtype]));


Verifying Index Usage with EXPLAIN
To confirm that your queries are actually using the indexes you've created, use the EXPLAIN command with your Cypher query wrapped in the cypher function.
SELECT * FROM cypher('my_graph', $$
    EXPLAIN MATCH (n:Person {name: 'Alice'}) RETURN n
$$) AS (plan TEXT);


The output plan will show you if an Index Scan or Bitmap Index Scan is being used instead of a less efficient Seq Scan (sequential scan).
Partitioning in Apache AGE
Partitioning is a PostgreSQL feature that divides a large table into smaller, more manageable child tables. This is especially useful for very large graphs where a single vertex or edge table becomes too large to manage efficiently.
Apache AGE, being a PostgreSQL extension, supports all of PostgreSQL's native partitioning methods, such as Range and Hash partitioning. You define partitioning on the underlying tables used by Apache AGE.
1. Hash Partitioning
Hash partitioning is useful when you want to distribute data evenly across partitions, for example, by the vertex or edge ID.
-- Create a partitioned table for 'Person' vertices based on the 'id' column
CREATE TABLE my_graph."Person_parent" (
    id AGTYPE,
    properties AGTYPE
) PARTITION BY HASH (id);

-- Create two partitions for the 'Person' table
CREATE TABLE my_graph."Person_p0" PARTITION OF my_graph."Person_parent"
FOR VALUES WITH (MODULUS 2, REMAINDER 0);

CREATE TABLE my_graph."Person_p1" PARTITION OF my_graph."Person_parent"
FOR VALUES WITH (MODULUS 2, REMAINDER 1);

-- Note: When using partitioning, you would need to manually manage the tables
-- or use a custom tool to create and manage the graph data across these partitions.
-- This approach is more complex than simple indexing but can be very effective for large, distributed datasets.


2. Range Partitioning
Range partitioning is useful for time-series data or data that can be logically grouped by a range, such as a date. For example, if your vertices have a created_at property, you could partition the data by year or month.
-- Create a parent table for 'Log' vertices with a 'created_at' property
CREATE TABLE my_graph."Log_parent" (
    id AGTYPE,
    properties AGTYPE
) PARTITION BY RANGE (agtype_access_operator(VARIADIC ARRAY[properties, '"created_at"'::agtype]));

-- Create partitions for different date ranges
CREATE TABLE my_graph."Log_2023" PARTITION OF my_graph."Log_parent"
FOR VALUES FROM ('2023-01-01'::agtype) TO ('2024-01-01'::agtype);

CREATE TABLE my_graph."Log_2024" PARTITION OF my_graph."Log_parent"
FOR VALUES FROM ('2024-01-01'::agtype) TO ('2025-01-01'::agtype);


Important Considerations for Partitioning:
Manual Management: Partitioning in Apache AGE requires more manual setup than indexing. You must first create the parent table and then the partitions.
Query Optimization: When querying a partitioned table, PostgreSQL's query planner can perform "partition pruning," which means it only scans the partitions that are relevant to the query's WHERE clause. This dramatically reduces the amount of data to be scanned.
Summary of Best Practices
Always create indexes: Don't rely on Apache AGE's default behavior, which is to not create any.
Use B-Tree for IDs: Create B-Tree indexes on the id, start_id, and end_id columns of your vertex and edge tables.
Use GIN for general property search: A GIN index on the properties column is good for general-purpose queries on the JSONB data.
Use specific B-Tree for key-value lookups: For frequently used properties, create a specific B-Tree index on that key within the properties column.
Consider partitioning for massive data: If your vertex or edge tables are growing to hundreds of millions or billions of rows, consider using PostgreSQL's partitioning to improve query performance and data management.
